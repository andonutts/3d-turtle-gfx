<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
        <title>3d-turtle-gfx</title>
        <style>
            #top-container {
                display: flex;
                justify-content: center;
                flex-wrap: wrap;
            }

            #canvas-container {
                margin-right: 10px;
            }

            #control-panel {
                min-width: 425px;
            }

            h1 {
                margin-top: 10px;
            }

            hr {
                color: #dcdcdc;
            }

            label > span {
                float: left;
                width: 200px;
            }

            label > input {
                width: 60px;
                padding: 0;
                -webkit-box-sizing: border-box;
                -moz-box-sizing: border-box;
                box-sizing: border-box;
            }

            .symbol-input {
                width: 30px;
                margin-right: 5px;
            }

            .rule-input {
                width: 280px;
            }

        </style>
    </head>
    <body>
        <script src="js/three.js"></script>
        <script src="js/controls/OrbitControls.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/MV.js"></script>
        <script>
            if ( !Detector.webgl ) {
                Detector.addGetWebGLMessage();
            }

            var renderer, scene, camera, controls;

            window.onload = function() {
                init();
                generateHilbertCurve();
                animate();
            }

            function init() {
                var canvasWidth = 512;
                var canvasHeight = 512;

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setSize( canvasWidth, canvasHeight );
                renderer.setClearColor( 0xf2f2f2, 1.0 );

                document.getElementById("canvas-container").appendChild( renderer.domElement );

                camera = new THREE.PerspectiveCamera( 45, canvasWidth / canvasHeight, 1, 1000 );
                camera.position.set( 50, 50, 50 );
                camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );

                scene = new THREE.Scene();
                
                controls = new THREE.OrbitControls( camera, renderer.domElement );
                controls.screenSpacePanning = true;
                controls.enableKeys = false;
                controls.minDistance = 10;
                controls.maxDistance = 500;

                addEventListeners();

                document.getElementById("preset-select").value = "";
            }

            function addEventListeners() {
                var presetSelect = document.getElementById("preset-select");
                presetSelect.onchange = function() {
                    switch(presetSelect.value) {
                        case "hilbert":
                            generateHilbertCurve();
                            break;
                        case "bush":
                            generateBush();
                            break;
                        case "dragon":
                            generateDragon();
                            break;
                        case "sierpinski-1":
                            generateSierpinskiGasket1();
                            break;
                        case "sierpinski-2":
                            generateSierpinskiGasket2();
                            break;
                        case "koch-curve":
                            generateKochCurve();
                            break;
                        case "koch-snowflake":
                            generateKochSnowflake();
                            break;
                        case "koch-island":
                            generateKochIsland();
                            break;
                        case "koch-island-lake":
                            generateKochIslandsAndLakes();
                            break;
                        case "2d-tree":
                            generate2dTree();
                            break;
                        default:

                    }
                }
            }

            function generateModel() {
                // clear the scene
                while(scene.children.length > 0){ 
                    scene.remove(scene.children[0]); 
                }

                // reset the camera and camera controls
                camera.position.set( 50, 50, 50 );
                camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );
                controls.reset();

                var stepSize = document.getElementById("step-size").value;
                var iterations = document.getElementById("order").value;
                var turnAngle = document.getElementById("turn-angle").value;

                var ruleset = [];
                var command = document.getElementById("base-axiom").value;
                var symbolList = document.querySelectorAll("input.symbol-input");
                var ruleList = document.querySelectorAll("input.rule-input");
                for(var i = 0; i < symbolList.length; i++) {
                    ruleset[symbolList[i].value] = ruleList[i].value;
                }

                var turters = new Turtle(stepSize, turnAngle);

                var commandEx = processLSystem(iterations, command, ruleset);
                drawLSystem(turters, commandEx);
                createGeometry(turters.vertices, turters.leafVertices);
            }

            function createGeometry(vertices, leafVertices) {
                var geometry = new THREE.BufferGeometry();
                geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
                var material = new THREE.LineBasicMaterial( { color: 0x4c4c4c } );
                var line = new THREE.LineSegments( geometry, material );
                scene.add( line );

                var leafGeometry = new THREE.BufferGeometry();
                leafGeometry.addAttribute( 'position', new THREE.Float32BufferAttribute( leafVertices, 3 ) );
                var leafMaterial = new THREE.MeshBasicMaterial( { color: 0x009933, side: THREE.DoubleSide } );
                var leafMesh = new THREE.Mesh( leafGeometry, leafMaterial );
                scene.add( leafMesh );
            }

            function animate() {
                requestAnimationFrame( animate );
                renderer.render( scene, camera );
            }

            function Turtle(stepSize, turnAngle) {
                this.stepSize = stepSize;
                this.turnAngle = turnAngle * Math.PI / 180;
                this.stateStack = [];
                this.vertices = [];
                this.leafVertices = [];

                // initialize at origin
                this.position = vec3( 0, 0, 0 );

                // initialize heading in the +y direction
                this.hlu = mat3(
                    0, 1, 0,
                    1, 0, 0,
                    0, 0, -1
                );

                this.moveForward = function() {
                    var h = vec3(
                        this.hlu[0][0],
                        this.hlu[1][0],
                        this.hlu[2][0]
                    );
                    
                    this.vertices.push(
                        this.position[0],
                        this.position[1],
                        this.position[2]
                    );
                    
                    this.position = add(this.position, scale(stepSize, h));
                    
                    this.vertices.push(
                        this.position[0],
                        this.position[1],
                        this.position[2]
                    );
                }

                this.moveForwardNoDraw = function() {
                    var h = vec3(
                        this.hlu[0][0],
                        this.hlu[1][0],
                        this.hlu[2][0]
                    );

                    this.position = add(this.position, scale(stepSize, h));
                }

                this.turnLeft = function() {
                    var d = -this.turnAngle;
                    var rot = mat3(
                        Math.cos(d), Math.sin(d), 0,
                        -Math.sin(d), Math.cos(d), 0,
                        0, 0, 1
                    );
                    this.hlu = mult(this.hlu, rot);
                };

                this.turnRight = function() {
                    var d =  this.turnAngle;
                    var rot = mat3(
                        Math.cos(d), Math.sin(d), 0,
                        -Math.sin(d), Math.cos(d), 0,
                        0, 0, 1
                    );
                    this.hlu = mult(this.hlu, rot);
                };

                this.pitchDown = function() {
                    var d = -this.turnAngle;
                    var rot = mat3(
                        Math.cos(d), 0, -Math.sin(d),
                        0, 1, 0,
                        Math.sin(d), 0, Math.cos(d)
                    );
                    this.hlu = mult(this.hlu, rot);
                };

                this.pitchUp = function() {
                    var d = this.turnAngle;
                    var rot = mat3(
                        Math.cos(d), 0, -Math.sin(d),
                        0, 1, 0,
                        Math.sin(d), 0, Math.cos(d)
                    );
                    this.hlu = mult(this.hlu, rot);
                };

                this.rollLeft = function() {
                    var d = -this.turnAngle;
                    var rot = mat3(
                        1, 0, 0,
                        0, Math.cos(d), -Math.sin(d),
                        0, Math.sin(d), Math.cos(d)
                    );
                    this.hlu = mult(this.hlu, rot);
                };

                this.rollRight = function() {
                    var d = this.turnAngle;
                    var rot = mat3(
                        1, 0, 0,
                        0, Math.cos(d), -Math.sin(d),
                        0, Math.sin(d), Math.cos(d)
                    );
                    this.hlu = mult(this.hlu, rot);
                };

                this.turnAround = function() {
                    var rot = mat3(
                        -1, 0, 0,
                        0, -1, 0,
                        0, 0, 1
                    );
                    this.hlu = mult(this.hlu, rot);
                }

                this.pushState = function() {
                    var turtleState = {
                        position : this.position,
                        hlu : this.hlu
                    };
                    this.stateStack.push(turtleState);
                };

                this.popState = function() {
                    var turtleState = this.stateStack.pop();
                    this.position = turtleState["position"];
                    this.hlu = turtleState["hlu"];
                };

                this.drawLeaf = function() {
                    var x = this.position[0], y = this.position[1], z = this.position[2];
                    var head = [ this.hlu[0][0], this.hlu[1][0], this.hlu[2][0] ];
                    var left = [ this.hlu[0][1], this.hlu[1][1], this.hlu[2][1] ];
                    var up = [ this.hlu[0][2], this.hlu[1][2], this.hlu[2][2] ];

                    this.leafVertices.push(
                        x, y, z,
                        x+head[0]+left[0]/2-up[0]/2, y+head[1]+left[1]/2-up[1]/2, z+head[2]+left[2]/2-up[2]/2,
                        x+2*head[0]-up[0], y+2*head[1]-up[1], z+2*head[2]-up[2],
                        x+2*head[0]-up[0], y+2*head[1]-up[1], z+2*head[2]-up[2],
                        x+head[0]-left[0]/2-up[0]/2, y+head[1]-left[1]/2-up[1]/2, z+head[2]-left[2]/2-up[2]/2,
                        x, y, z
                    );
                }
            }

            function processLSystem(iterations, command, ruleset) {
                var re = /[\+\-\&\^\\\/\|\[\]]/g;
                for(var i = 0; i < iterations; i++) {
                    var buffer = "";
                    for(var j = 0; j < command.length; j++) {
                        var symbol = command.charAt(j);
                        if(!re.test(symbol) && ruleset[symbol] != null) {
                            buffer += ruleset[symbol];
                        } else {
                            buffer += symbol;
                        }
                    }
                    command = buffer;
                }
                return command;
            }

            function drawLSystem(turtle, command) {
                for(var i = 0; i < command.length; i++) {
                    switch(command.charAt(i)) {
                        case "F":
                            turtle.moveForward();
                            break;
                        case "f":
                            turtle.moveForwardNoDraw();
                            break;
                        case "+":
                            turtle.turnLeft();
                            break;
                        case "-":
                            turtle.turnRight();
                            break;
                        case "&":
                            turtle.pitchDown();
                            break;
                        case "^":
                            turtle.pitchUp();
                            break;
                        case "\\":
                            turtle.rollLeft();
                            break;
                        case "/":
                            turtle.rollRight();
                            break;
                        case "|":
                            turtle.turnAround();
                            break;
                        case "[":
                            turtle.pushState();
                            break;
                        case "]":
                            turtle.popState();
                            break;
                        case "L":
                            turtle.drawLeaf();
                            break;
                        default:

                    }
                }
            }

            function addRule() {
                var ruleTable = document.getElementById("rule-table");
                var row = ruleTable.insertRow();
                row.classList.add("rule-set");
                var symbolCell = row.insertCell();
                var ruleCell = row.insertCell();
                var deleteCell = row.insertCell();

                symbolCell.innerHTML = '<input type="text" class="symbol-input" maxlength="1" />&#8594;';
                ruleCell.innerHTML = '<input type="text" class="rule-input" />';
                deleteCell.innerHTML = '<button onclick="deleteRule(this)">Delete</button>'
            }

            function deleteRule(r) {
                var i = r.parentNode.parentNode.rowIndex;
                document.getElementById("rule-table").deleteRow(i);
            }

            function setRuleCount(count) {
                while(document.querySelectorAll("tr.rule-set").length < count) {
                    addRule();
                }
                while(document.querySelectorAll("tr.rule-set").length > count) {
                    var lastRow = document.querySelectorAll("tr.rule-set").length - 1;
                    document.getElementById("rule-table").deleteRow(lastRow);
                }
            }

            function generateHilbertCurve() {
                setRuleCount(4);

                document.getElementById("step-size").value = "4";
                document.getElementById("order").value = "2";
                document.getElementById("turn-angle").value = "90";
                document.getElementById("base-axiom").value = "A";

                symbolList = document.querySelectorAll("input.symbol-input");
                ruleList = document.querySelectorAll("input.rule-input");
                
                symbolList[0].value = "A";
                ruleList[0].value = "B-F+CFC+F-D&F^D-F+&&CFC+F+B//";

                symbolList[1].value = "B";
                ruleList[1].value = "A&F^CFB^F^D^^-F-D^|F^B|FC^F^A//";

                symbolList[2].value = "C";
                ruleList[2].value = "|D^|F^B-F+C^F^A&&FA&F^C+F+B^F^D//";

                symbolList[3].value = "D";
                ruleList[3].value = "|CFB-F+B|FA&F^A&&FB-F+B|FC//";

                generateModel();
            }

            function generateBush() {
                setRuleCount(4);

                document.getElementById("step-size").value = "2";
                document.getElementById("order").value = "4";
                document.getElementById("turn-angle").value = "22.5";
                document.getElementById("base-axiom").value = "A";

                symbolList = document.querySelectorAll("input.symbol-input");
                ruleList = document.querySelectorAll("input.rule-input");
                
                symbolList[0].value = "A";
                ruleList[0].value = "[&FLA]/////[&FLA]///////[&FLA]";

                symbolList[1].value = "F";
                ruleList[1].value = "S/////F";

                symbolList[2].value = "S";
                ruleList[2].value = "FL";

                symbolList[3].value = "L";
                ruleList[3].value = "[^^-f+f+f-|-f+f+f]";

                generateModel();
            }

            function generateDragon() {
                setRuleCount(1);

                document.getElementById("step-size").value = "3";
                document.getElementById("order").value = "5";
                document.getElementById("turn-angle").value = "30";
                document.getElementById("base-axiom").value = "F";

                symbolList = document.querySelectorAll("input.symbol-input");
                ruleList = document.querySelectorAll("input.rule-input");
                
                symbolList[0].value = "F";
                ruleList[0].value = "-F++++F----F+";

                generateModel();
            }

            function generateSierpinskiGasket1() {
                setRuleCount(1);

                document.getElementById("step-size").value = "1";
                document.getElementById("order").value = "4";
                document.getElementById("turn-angle").value = "120";
                document.getElementById("base-axiom").value = "F";

                symbolList = document.querySelectorAll("input.symbol-input");
                ruleList = document.querySelectorAll("input.rule-input");
                
                symbolList[0].value = "F";
                ruleList[0].value = "F+F-F-F+F";

                generateModel();
            }

            function generateSierpinskiGasket2() {
                setRuleCount(3);

                document.getElementById("step-size").value = "1";
                document.getElementById("order").value = "4";
                document.getElementById("turn-angle").value = "60";
                document.getElementById("base-axiom").value = "FX";

                symbolList = document.querySelectorAll("input.symbol-input");
                ruleList = document.querySelectorAll("input.rule-input");
                
                symbolList[0].value = "F";
                ruleList[0].value = "Z";
                
                symbolList[1].value = "X";
                ruleList[1].value = "+FY-FX-FY+";

                symbolList[2].value = "Y";
                ruleList[2].value = "-FX+FY+FX-";

                generateModel();
            }

            function generateKochCurve() {
                setRuleCount(1);

                document.getElementById("step-size").value = "2";
                document.getElementById("order").value = "3";
                document.getElementById("turn-angle").value = "90";
                document.getElementById("base-axiom").value = "F-F-F-F";

                symbolList = document.querySelectorAll("input.symbol-input");
                ruleList = document.querySelectorAll("input.rule-input");
                
                symbolList[0].value = "F";
                ruleList[0].value = "FF-F+F-F-FF";

                generateModel();
            }                      

            function generateKochSnowflake() {
                setRuleCount(1);

                document.getElementById("step-size").value = "1";
                document.getElementById("order").value = "2";
                document.getElementById("turn-angle").value = "60";
                document.getElementById("base-axiom").value = "F++F++F";

                symbolList = document.querySelectorAll("input.symbol-input");
                ruleList = document.querySelectorAll("input.rule-input");
                
                symbolList[0].value = "F";
                ruleList[0].value = "F-F++F-F";

                generateModel();
            }

            function generateKochIsland() {
                setRuleCount(1);

                document.getElementById("step-size").value = "1";
                document.getElementById("order").value = "2";
                document.getElementById("turn-angle").value = "90";
                document.getElementById("base-axiom").value = "F-F-F-F";

                symbolList = document.querySelectorAll("input.symbol-input");
                ruleList = document.querySelectorAll("input.rule-input");
                
                symbolList[0].value = "F";
                ruleList[0].value = "F-F+F+FF-F-F+F";

                generateModel();
            }

            function generateKochIslandsAndLakes() {
                setRuleCount(2);

                document.getElementById("step-size").value = "1";
                document.getElementById("order").value = "2";
                document.getElementById("turn-angle").value = "90";
                document.getElementById("base-axiom").value = "F+F+F+F";

                symbolList = document.querySelectorAll("input.symbol-input");
                ruleList = document.querySelectorAll("input.rule-input");
                
                symbolList[0].value = "F";
                ruleList[0].value = "F+f-FF+F+FF+Ff+FF-f+FF-F-FF-Ff-FFF";

                symbolList[1].value = "f";
                ruleList[1].value = "ffffff";

                generateModel();
            }

            function generate2dTree() {
                setRuleCount(2);

                document.getElementById("step-size").value = "0.2";
                document.getElementById("order").value = "7";
                document.getElementById("turn-angle").value = "20";
                document.getElementById("base-axiom").value = "X";

                symbolList = document.querySelectorAll("input.symbol-input");
                ruleList = document.querySelectorAll("input.rule-input");
                
                symbolList[0].value = "X";
                ruleList[0].value = "F[+X]F[-X]+X";

                symbolList[1].value = "F";
                ruleList[1].value = "FF";

                generateModel();
            }

        </script>
        <div id="top-container">
            <div id="canvas-container"></div>
            <div id="control-panel">
                <h1>3d-turtle-gfx</h1>
                <label><span>d, step size</span><input type="number" id="step-size" min="0" step="0.1" /></label><br />
                <label><span>n, number of recursions</span><input type="number" id="order" min="1" /></label><br />
                <label><span>&delta;, angle increment (degrees)</span><input type="number" id="turn-angle" step="0.01" /></label><br />
                <br />
                <label><span>Base axiom</span></label><br />
                <input type="text" id="base-axiom" /><br />
                <br />
                <label>Production rules</label>
                <table id="rule-table">
                    <tr class="rule-set">
                        <td><input type="text" class="symbol-input" maxlength="1" />&#8594;</td>
                        <td><input type="text" class="rule-input" /></td>
                    </tr>
                </table>
                <button onclick="addRule()">Add New Rule</button><br />
                <br />
                <button onclick="generateModel()">Generate L-System</button>
                <br />

                <hr>

                <label>Presets</label>
                <select id="preset-select">
                    <option value="">Select a preset...</option>
                    <option value="hilbert">Hilbert curve</option>
                    <option value="bush">Bush-like structure</option>
                    <option value="dragon">Dragon curve</option>
                    <option value="sierpinski-1">Sierpinski gasket 1</option>
                    <option value="sierpinski-2">Sierpinski gasket 2</option>
                    <option value="koch-curve">Koch curve</option>
                    <option value="koch-snowflake">Koch snowflake</option>
                    <option value="koch-island">Koch island</option>
                    <option value="koch-island-lake">Koch islands and lakes</option>
                    <option value="2d-tree">2D tree</option>
                </select>
            </div>
        </div>
    </body>
</html>
