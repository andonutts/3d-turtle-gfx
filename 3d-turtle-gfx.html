<!DOCTYPE html>
<html>
    <head>
        <meta charset=utf-8>
        <title>3D Turtle Graphics Renderer</title>
        <style>
        </style>
    </head>
    <body>
        <script src="js/three.js"></script>
        <script src="js/controls/OrbitControls.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/MV.js"></script>
        <script>
            if ( !Detector.webgl ) {
                Detector.addGetWebGLMessage();
            }

            var renderer, scene, camera, controls;

            window.onload = function() {
                init();
                generateHilbertCurve();
                animate();
            }

            function init() {
                var canvasWidth = 800;
                var canvasHeight = 512;

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setSize( canvasWidth, canvasHeight );
                renderer.setClearColor( 0xf2f2f2, 1.0 );

                document.getElementById("canvas-container").appendChild( renderer.domElement );

                camera = new THREE.PerspectiveCamera( 45, canvasWidth / canvasHeight, 1, 1000 );
                camera.position.set( 50, 50, 50 );
                camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );

                scene = new THREE.Scene();
                
                controls = new THREE.OrbitControls( camera, renderer.domElement );
                // controls.enablePan = false;
                controls.screenSpacePanning = true;
                controls.minDistance = 10;
                controls.maxDistance = 500;
            }

            function generateModel() {
                // clear the scene
                while(scene.children.length > 0){ 
                    scene.remove(scene.children[0]); 
                }

                var iterations = document.getElementById("order").value;
                var turnAngle = document.getElementById("turn-angle").value;
                var stepSize = 3;

                var ruleset = [];
                var command = document.getElementById("base-axiom").value;
                var symbolList = document.querySelectorAll("input.symbol-input");
                var ruleList = document.querySelectorAll("input.rule-input");
                for(var i = 0; i < symbolList.length; i++) {
                    ruleset[symbolList[i].value] = ruleList[i].value;
                }

                var turters = new Turtle(stepSize, turnAngle);

                var commandEx = processLSystem(iterations, command, ruleset);
                drawLSystem(turters, commandEx);
                createGeometry(turters.vertices);
            }

            function createGeometry(vertices) {
                var geometry = new THREE.BufferGeometry();
                geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
                var material = new THREE.LineBasicMaterial( { color: 0x4c4c4c } );
                var line = new THREE.LineSegments( geometry, material );
                scene.add( line );
            }

            function animate() {
                requestAnimationFrame( animate );
                renderer.render( scene, camera );
            }

            function Turtle(stepSize, turnAngle) {
                this.stepSize = stepSize;
                this.turnAngle = turnAngle * Math.PI / 180;
                this.stateStack = [];
                this.vertices = [];

                // initialize at origin
                this.position = vec3( 0, 0, 0 );

                // initialize heading in the +y direction
                this.hlu = mat3(
                    0, 1, 0,
                    1, 0, 0,
                    0, 0, -1
                );

                this.moveForward = function() {
                    var h = vec3(
                        this.hlu[0][0],
                        this.hlu[1][0],
                        this.hlu[2][0]
                    );
                    
                    this.vertices.push(
                        this.position[0],
                        this.position[1],
                        this.position[2]
                    );
                    
                    this.position = add(this.position, scale(stepSize, h));
                    
                    this.vertices.push(
                        this.position[0],
                        this.position[1],
                        this.position[2]
                    );
                }

                this.moveForwardNoDraw = function() {
                    var h = vec3(
                        this.hlu[0][0],
                        this.hlu[1][0],
                        this.hlu[2][0]
                    );

                    this.position = add(this.position, scale(stepSize, h));
                }

                this.turnLeft = function() {
                    var d = -this.turnAngle;
                    var rot = mat3(
                        Math.cos(d), Math.sin(d), 0,
                        -Math.sin(d), Math.cos(d), 0,
                        0, 0, 1
                    );
                    this.hlu = mult(this.hlu, rot);
                };

                this.turnRight = function() {
                    var d =  this.turnAngle;
                    var rot = mat3(
                        Math.cos(d), Math.sin(d), 0,
                        -Math.sin(d), Math.cos(d), 0,
                        0, 0, 1
                    );
                    this.hlu = mult(this.hlu, rot);
                };

                this.pitchDown = function() {
                    var d = -this.turnAngle;
                    var rot = mat3(
                        Math.cos(d), 0, -Math.sin(d),
                        0, 1, 0,
                        Math.sin(d), 0, Math.cos(d)
                    );
                    this.hlu = mult(this.hlu, rot);
                };

                this.pitchUp = function() {
                    var d = this.turnAngle;
                    var rot = mat3(
                        Math.cos(d), 0, -Math.sin(d),
                        0, 1, 0,
                        Math.sin(d), 0, Math.cos(d)
                    );
                    this.hlu = mult(this.hlu, rot);
                };

                this.rollLeft = function() {
                    var d = -this.turnAngle;
                    var rot = mat3(
                        1, 0, 0,
                        0, Math.cos(d), -Math.sin(d),
                        0, Math.sin(d), Math.cos(d)
                    );
                    this.hlu = mult(this.hlu, rot);
                };

                this.rollRight = function() {
                    var d = this.turnAngle;
                    var rot = mat3(
                        1, 0, 0,
                        0, Math.cos(d), -Math.sin(d),
                        0, Math.sin(d), Math.cos(d)
                    );
                    this.hlu = mult(this.hlu, rot);
                };

                this.turnAround = function() {
                    var rot = mat3(
                        -1, 0, 0,
                        0, -1, 0,
                        0, 0, 1
                    );
                    this.hlu = mult(this.hlu, rot);
                }

                this.pushState = function() {
                    var turtleState = {
                        position : this.position,
                        hlu : this.hlu
                    };
                    this.stateStack.push(turtleState);
                };

                this.popState = function() {
                    var turtleState = this.stateStack.pop();
                    this.position = turtleState["position"];
                    this.hlu = turtleState["hlu"];
                };
            }

            function processLSystem(iterations, command, ruleset) {
                var re = /[\+\-\&\^\\\/\|\[\]]/g;
                for(var i = 0; i < iterations; i++) {
                    var buffer = "";
                    for(var j = 0; j < command.length; j++) {
                        var symbol = command.charAt(j);
                        if(!re.test(symbol) && ruleset[symbol] != null) {
                            buffer += ruleset[symbol];
                        } else {
                            buffer += symbol;
                        }
                    }
                    command = buffer;
                }
                return command;
            }

            function drawLSystem(turtle, command) {
                for(var i = 0; i < command.length; i++) {
                    switch(command.charAt(i)) {
                        case "F":
                            turtle.moveForward();
                            break;
                        case "f":
                            turtle.moveForwardNoDraw();
                            break;
                        case "+":
                            turtle.turnLeft();
                            break;
                        case "-":
                            turtle.turnRight();
                            break;
                        case "&":
                            turtle.pitchDown();
                            break;
                        case "^":
                            turtle.pitchUp();
                            break;
                        case "\\":
                            turtle.rollLeft();
                            break;
                        case "/":
                            turtle.rollRight();
                            break;
                        case "|":
                            turtle.turnAround();
                            break;
                        case "[":
                            turtle.pushState();
                            break;
                        case "]":
                            turtle.popState();
                            break;
                        default:

                    }
                }
            }

            function addRule() {
                var ruleTable = document.getElementById("rule-table");
                var row = ruleTable.insertRow();
                row.classList.add("rule-set");
                var symbolCell = row.insertCell();
                var ruleCell = row.insertCell();
                var deleteCell = row.insertCell();

                symbolCell.innerHTML = '<input type="text" class="symbol-input" />';
                ruleCell.innerHTML = '<input type="text" class="rule-input" />';
                deleteCell.innerHTML = '<button onclick="deleteRule(this)">Delete Rule</button>'
            }

            function deleteRule(r) {
                var i = r.parentNode.parentNode.rowIndex;
                document.getElementById("rule-table").deleteRow(i);
            }

            function generateHilbertCurve() {
                while(document.querySelectorAll("tr.rule-set").length < 4) {
                    addRule();
                }

                document.getElementById("order").value = "2";
                document.getElementById("turn-angle").value = "90";
                document.getElementById("base-axiom").value = "A";

                symbolList = document.querySelectorAll("input.symbol-input");
                ruleList = document.querySelectorAll("input.rule-input");
                
                symbolList[0].value = "A";
                ruleList[0].value = "B-F+CFC+F-D&F^D-F+&&CFC+F+B//";

                symbolList[1].value = "B";
                ruleList[1].value = "A&F^CFB^F^D^^-F-D^|F^B|FC^F^A//";

                symbolList[2].value = "C";
                ruleList[2].value = "|D^|F^B-F+C^F^A&&FA&F^C+F+B^F^D//";

                symbolList[3].value = "D";
                ruleList[3].value = "|CFB-F+B|FA&F^A&&FB-F+B|FC//";

                generateModel();
            }

        </script>
        <div id="canvas-container"></div>
        <div id="control-panel">
            <label><span>n</span><input type="text" id="order" /></label><br />
            <label><span>&delta;</span><input type="text" id="turn-angle" /></label><br />
            <label><span>Base axiom</span><input type="text" id="base-axiom" /></label><br />
            <table id="rule-table">
                <tr>
                    <th>Symbol</th>
                    <th>Rule</th>
                </tr>
                <tr class="rule-set">
                    <td><input type="text" class="symbol-input" /></td>
                    <td><input type="text" class="rule-input" /></td>
                </tr>
            </table>
            <button onclick="addRule()">Add New Rule</button><br />
            <button onclick="generateModel()">Generate</button>
        </div>
    </body>
</html>
